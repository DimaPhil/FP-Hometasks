
==================== FINAL INTERFACE ====================
2016-11-07 14:51:59.35572 UTC

interface hw6-0.1.0.0-3LNkNAhD9rXI9R806tlhLb:TreeWriter 8001
  interface hash: 0925dc901f3c101bab9b39b4f8b5b0a6
  ABI hash: eb8573384be26f8f666f6e76c0542820
  export-list hash: b7d2a66bfc5257381808c6b257fcdba4
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b159a15c55fa7c6870cb2eb79bbae5a5
  sig of: Nothing
  used TH splices: False
  where
exports:
  TreeWriter.delete
  TreeWriter.find
  TreeWriter.findMax
  TreeWriter.findVertex
  TreeWriter.insert
  TreeWriter.merge
  TreeWriter.next
  TreeWriter.upgradeMaybe
  TreeWriter.Tree{TreeWriter.Leaf TreeWriter.Node}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Functor.Identity base-4.9.0.0:Data.List.NonEmpty
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Semigroup
                         base-4.9.0.0:Data.Type.Equality base-4.9.0.0:Data.Version
                         base-4.9.0.0:Data.Void base-4.9.0.0:GHC.Exts
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.Writer 57defc881a9014c3d1c218e1b5d9eb02
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.Writer.Class b5441ea40f86d16e137ade97de751e19
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Writer.Lazy fddf2f22dc507f4f4168c5e3805cb667
a383094223a71623764e814693c66512
  $fShowTree :: GHC.Show.Show a => GHC.Show.Show (TreeWriter.Tree a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (TreeWriter.Tree a)
                  (TreeWriter.$fShowTree_$cshowsPrec @ a $dShow)
                  (TreeWriter.$fShowTree_$cshow @ a $dShow)
                  (TreeWriter.$fShowTree_$cshowList @ a $dShow) -}
6a818867f6941c60ccbc093f7dd0d076
  $fShowTree1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
a383094223a71623764e814693c66512
  $fShowTree_$cshow ::
    GHC.Show.Show a => TreeWriter.Tree a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: TreeWriter.Tree a) ->
                 TreeWriter.$fShowTree_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a383094223a71623764e814693c66512
  $fShowTree_$cshowList ::
    GHC.Show.Show a => [TreeWriter.Tree a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [TreeWriter.Tree a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TreeWriter.Tree a)
                   (TreeWriter.$fShowTree_$cshowsPrec
                      @ a
                      $dShow
                      TreeWriter.$fShowTree1)
                   eta
                   eta1) -}
a383094223a71623764e814693c66512
  $fShowTree_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> TreeWriter.Tree a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><L,1*U(U)><S,1*U> -}
f4bd9922eca1631d521089a3c1d7bff6
  $tc'Leaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14192790366072395087##
                   18382578389413899697##
                   TreeWriter.$trModule
                   TreeWriter.$tc'Leaf1) -}
94e61e592093ffa4d04f1b39efdcd660
  $tc'Leaf1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Leaf"#) -}
54854497e845ff808b51251f4a3713d1
  $tc'Node :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4858329955599382794##
                   908220335886441812##
                   TreeWriter.$trModule
                   TreeWriter.$tc'Node1) -}
071fb99577a4e124e9d8fe20279ef06e
  $tc'Node1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Node"#) -}
6d5bf97872b2116884be060de4d74e64
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4192148316327830941##
                   1384701196133233890##
                   TreeWriter.$trModule
                   TreeWriter.$tcTree1) -}
c69ba21d2d3d11aa003fb60963e7e327
  $tcTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tree"#) -}
7c0db0bba49cb84db0a3ec03c272df71
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   TreeWriter.$trModule2
                   TreeWriter.$trModule1) -}
b41331bbb3a691d98ffa40cb96f15fd0
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "TreeWriter"#) -}
e19bebdca5cda3c0e723d564bc9d7daf
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "hw6-0.1.0.0-3LNkNAhD9rXI9R806tlhLb"#) -}
b062607b25274bbff742cde41eea81d6
  $wdelete ::
    (GHC.Show.Show a, GHC.Classes.Ord a) =>
    TreeWriter.Tree a -> a -> (# TreeWriter.Tree a, GHC.Base.String #)
  {- Arity: 4,
     Strictness: <L,U(A,C(U),A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><S,1*U><L,U>,
     Inline: [0] -}
d58b2365ab1f00721da72bf36701c978
  $wfind ::
    (GHC.Show.Show a, GHC.Classes.Ord a) =>
    TreeWriter.Tree a -> a -> (# TreeWriter.Tree a, GHC.Base.String #)
  {- Arity: 4,
     Strictness: <L,U(A,C(U),A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Classes.Ord a)
                   (w2 :: TreeWriter.Tree a)
                   (w3 :: a) ->
                 let {
                   ds :: Control.Monad.Trans.Writer.Lazy.Writer
                           GHC.Base.String (TreeWriter.Tree a)
                   = case TreeWriter.$wfindVertex
                            @ a
                            w
                            w1
                            w2
                            w3 of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(TreeWriter.Tree a, GHC.Base.String)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <GHC.Base.String>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <TreeWriter.Tree a>_N))) }
                 } in
                 (# case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <[GHC.Types.Char]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <TreeWriter.Tree a>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <(TreeWriter.Tree a,
                                     [GHC.Types.Char])>_R)) of wild { (,) a1 w4 ->
                    a1 },
                    case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <[GHC.Types.Char]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <TreeWriter.Tree a>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <(TreeWriter.Tree a,
                                     [GHC.Types.Char])>_R)) of wild { (,) a1 w4 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      w4
                      (GHC.CString.unpackAppendCString#
                         "trying to find "#
                         (GHC.Show.show @ a w w3)) } #)) -}
57608d0cd5ac9ea9d83c1742f893a88f
  $wfindMax :: TreeWriter.Tree a -> (# a, GHC.Base.String #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
cf8f9f88dd837f0f884c825b76ef974e
  $wfindVertex ::
    (GHC.Show.Show a, GHC.Classes.Ord a) =>
    TreeWriter.Tree a -> a -> (# TreeWriter.Tree a, GHC.Base.String #)
  {- Arity: 4,
     Strictness: <L,U(A,C(U),A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><S,1*U><L,U>,
     Inline: [0] -}
fd6b498f5c48c313bab04b45f29ef6ad
  $winsert ::
    (GHC.Show.Show a, GHC.Classes.Ord a) =>
    TreeWriter.Tree a -> a -> (# TreeWriter.Tree a, GHC.Base.String #)
  {- Arity: 4,
     Strictness: <L,U(A,C(U),A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><S,1*U><L,U>,
     Inline: [0] -}
edaf820397a59ccdb7de5e7ba73e2389
  $wmerge ::
    (GHC.Show.Show a, GHC.Classes.Ord a) =>
    TreeWriter.Tree a
    -> TreeWriter.Tree a -> (# TreeWriter.Tree a, GHC.Base.String #)
  {- Arity: 4,
     Strictness: <L,U(A,C(U),A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Classes.Ord a)
                   (w2 :: TreeWriter.Tree a)
                   (w3 :: TreeWriter.Tree a) ->
                 case w2 of wild {
                   TreeWriter.Leaf
                   -> case w3 of wild1 {
                        TreeWriter.Leaf -> (# TreeWriter.Leaf @ a, TreeWriter.merge4 #)
                        TreeWriter.Node ipv ipv1 ipv2 -> (# wild1, TreeWriter.merge3 #) }
                   TreeWriter.Node ipv ipv1 ipv2
                   -> case w3 of wild1 {
                        TreeWriter.Leaf -> (# wild, TreeWriter.merge2 #)
                        TreeWriter.Node ipv3 ipv4 ipv5
                        -> let {
                             ds :: Control.Monad.Trans.Writer.Lazy.Writer GHC.Base.String a
                             = case TreeWriter.$wfindMax @ a wild of ww { (#,#) ww1 ww2 ->
                               (ww1, ww2)
                                 `cast`
                               (Trans
                                    (Sym (Data.Functor.Identity.N:Identity[0]
                                              <(a, GHC.Base.String)>_R))
                                    (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                              <GHC.Base.String>_N
                                              <Data.Functor.Identity.Identity>_R
                                              <a>_N))) }
                           } in
                           let {
                             best :: a
                             = case ds
                                      `cast`
                                    (Trans
                                         (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                              <[GHC.Types.Char]>_N
                                              <Data.Functor.Identity.Identity>_R
                                              <a>_N)
                                         (Data.Functor.Identity.N:Identity[0]
                                              <(a, [GHC.Types.Char])>_R)) of wild2 { (,) a1 w4 ->
                               a1 }
                           } in
                           let {
                             ds1 :: Control.Monad.Trans.Writer.Lazy.Writer
                                      GHC.Base.String (TreeWriter.Tree a)
                             = case TreeWriter.$wdelete
                                      @ a
                                      w
                                      w1
                                      wild
                                      best of ww { (#,#) ww1 ww2 ->
                               (ww1, ww2)
                                 `cast`
                               (Trans
                                    (Sym (Data.Functor.Identity.N:Identity[0]
                                              <(TreeWriter.Tree a, GHC.Base.String)>_R))
                                    (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                              <GHC.Base.String>_N
                                              <Data.Functor.Identity.Identity>_R
                                              <TreeWriter.Tree a>_N))) }
                           } in
                           (# TreeWriter.Node
                                @ a
                                best
                                (case ds1
                                        `cast`
                                      (Trans
                                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                <[GHC.Types.Char]>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <TreeWriter.Tree a>_N)
                                           (Data.Functor.Identity.N:Identity[0]
                                                <(TreeWriter.Tree a,
                                                  [GHC.Types.Char])>_R)) of wild2 { (,) a1 w4 ->
                                 a1 })
                                wild1,
                              case ds
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <[GHC.Types.Char]>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <a>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(a, [GHC.Types.Char])>_R)) of wild2 { (,) a1 w4 ->
                              GHC.Base.++
                                @ GHC.Types.Char
                                w4
                                (case ds1
                                        `cast`
                                      (Trans
                                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                <[GHC.Types.Char]>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <TreeWriter.Tree a>_N)
                                           (Data.Functor.Identity.N:Identity[0]
                                                <(TreeWriter.Tree a,
                                                  [GHC.Types.Char])>_R)) of wild3 { (,) a2 w5 ->
                                 GHC.Base.++ @ GHC.Types.Char w5 TreeWriter.merge1 }) } #) } }) -}
a562467ed838eb51eb37146d80fd21a2
  $wnext ::
    GHC.Classes.Ord a =>
    TreeWriter.Tree a -> a -> (# GHC.Base.Maybe a, GHC.Base.String #)
  {- Arity: 3, Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S,1*U><L,U>,
     Inline: [0] -}
a383094223a71623764e814693c66512
  data Tree a = Leaf | Node a (TreeWriter.Tree a) (TreeWriter.Tree a)
a992581ca78e57aba3709b7713dd5e90
  delete ::
    (GHC.Show.Show a, GHC.Classes.Ord a) =>
    TreeWriter.Tree a
    -> a
    -> Control.Monad.Trans.Writer.Lazy.Writer
         GHC.Base.String (TreeWriter.Tree a)
  {- Arity: 4,
     Strictness: <L,U(A,C(U),A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><S,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Classes.Ord a)
                   (w2 :: TreeWriter.Tree a)
                   (w3 :: a) ->
                 case TreeWriter.$wdelete @ a w w1 w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(TreeWriter.Tree a, GHC.Base.String)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <GHC.Base.String>_N
                                <Data.Functor.Identity.Identity>_R
                                <TreeWriter.Tree a>_N))) }) -}
776e2487d0051cabc333718a36f4a531
  find ::
    (GHC.Show.Show a, GHC.Classes.Ord a) =>
    TreeWriter.Tree a
    -> a
    -> Control.Monad.Trans.Writer.Lazy.Writer
         GHC.Base.String (TreeWriter.Tree a)
  {- Arity: 4,
     Strictness: <L,U(A,C(U),A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><L,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Classes.Ord a)
                   (w2 :: TreeWriter.Tree a)
                   (w3 :: a) ->
                 case TreeWriter.$wfind @ a w w1 w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(TreeWriter.Tree a, GHC.Base.String)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <GHC.Base.String>_N
                                <Data.Functor.Identity.Identity>_R
                                <TreeWriter.Tree a>_N))) }) -}
56720fcbbe1c02df8ec397f4619ba780
  findMax ::
    GHC.Classes.Ord a =>
    TreeWriter.Tree a
    -> Control.Monad.Trans.Writer.Lazy.Writer GHC.Base.String a
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: TreeWriter.Tree a) ->
                 case TreeWriter.$wfindMax @ a w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(a, GHC.Base.String)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <GHC.Base.String>_N
                                <Data.Functor.Identity.Identity>_R
                                <a>_N))) }) -}
45ca6a2f31f05f09d77caa17d0ef8143
  findVertex ::
    (GHC.Show.Show a, GHC.Classes.Ord a) =>
    TreeWriter.Tree a
    -> a
    -> Control.Monad.Trans.Writer.Lazy.Writer
         GHC.Base.String (TreeWriter.Tree a)
  {- Arity: 4,
     Strictness: <L,U(A,C(U),A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><S,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Classes.Ord a)
                   (w2 :: TreeWriter.Tree a)
                   (w3 :: a) ->
                 case TreeWriter.$wfindVertex
                        @ a
                        w
                        w1
                        w2
                        w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(TreeWriter.Tree a, GHC.Base.String)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <GHC.Base.String>_N
                                <Data.Functor.Identity.Identity>_R
                                <TreeWriter.Tree a>_N))) }) -}
95f5e39ee339d1fe6619f117fd6e04c4
  insert ::
    (GHC.Show.Show a, GHC.Classes.Ord a) =>
    TreeWriter.Tree a
    -> a
    -> Control.Monad.Trans.Writer.Lazy.Writer
         GHC.Base.String (TreeWriter.Tree a)
  {- Arity: 4,
     Strictness: <L,U(A,C(U),A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><S,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Classes.Ord a)
                   (w2 :: TreeWriter.Tree a)
                   (w3 :: a) ->
                 case TreeWriter.$winsert @ a w w1 w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(TreeWriter.Tree a, GHC.Base.String)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <GHC.Base.String>_N
                                <Data.Functor.Identity.Identity>_R
                                <TreeWriter.Tree a>_N))) }) -}
aee3bc751f09682f232ed5f45b6ccc38
  merge ::
    (GHC.Show.Show a, GHC.Classes.Ord a) =>
    TreeWriter.Tree a
    -> TreeWriter.Tree a
    -> Control.Monad.Trans.Writer.Lazy.Writer
         GHC.Base.String (TreeWriter.Tree a)
  {- Arity: 4,
     Strictness: <L,U(A,C(U),A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Classes.Ord a)
                   (w2 :: TreeWriter.Tree a)
                   (w3 :: TreeWriter.Tree a) ->
                 case TreeWriter.$wmerge @ a w w1 w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(TreeWriter.Tree a, GHC.Base.String)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <GHC.Base.String>_N
                                <Data.Functor.Identity.Identity>_R
                                <TreeWriter.Tree a>_N))) }) -}
8e4538b612952f16dce97e1b7eddf801
  merge1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Merging two non-empty trees"#) -}
6fc3f472784c545041e0a0cc7ecfc8df
  merge2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Merging non-empty tree and empty"#) -}
006d8f998858d4a013b9a242d8dbf10f
  merge3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Merging empty tree and non-empty"#) -}
b74add0cfa92d02e956cf4f800024a7d
  merge4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Merging two empty trees"#) -}
598796869ff4bf29fdcd66f09a19a6ef
  next ::
    GHC.Classes.Ord a =>
    TreeWriter.Tree a
    -> a
    -> Control.Monad.Trans.Writer.Lazy.Writer
         GHC.Base.String (GHC.Base.Maybe a)
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: TreeWriter.Tree a)
                   (w2 :: a) ->
                 case TreeWriter.$wnext @ a w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Base.Maybe a, GHC.Base.String)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <GHC.Base.String>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Base.Maybe a>_N))) }) -}
568fbb6aa076d0f84d619bffabbc1a7e
  upgradeMaybe :: GHC.Base.Maybe a -> a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (ds :: GHC.Base.Maybe a) (x :: a) ->
                 case ds of wild {
                   GHC.Base.Nothing -> GHC.Base.Just @ a x
                   GHC.Base.Just x1 -> GHC.Base.Just @ a x1 }) -}
instance [safe] GHC.Show.Show [TreeWriter.Tree]
  = TreeWriter.$fShowTree
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

