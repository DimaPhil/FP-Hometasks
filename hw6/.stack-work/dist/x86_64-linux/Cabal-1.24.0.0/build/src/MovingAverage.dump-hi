
==================== FINAL INTERFACE ====================
2016-11-07 14:51:58.898192 UTC

interface hw6-0.1.0.0-3LNkNAhD9rXI9R806tlhLb:MovingAverage 8001
  interface hash: 084b94031bad623bc62d72ee56849f09
  ABI hash: 65e9e229695dfbec102c0c66fdec44a5
  export-list hash: d11f8a59a0b19953a52d3f30021fc6ad
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b159a15c55fa7c6870cb2eb79bbae5a5
  sig of: Nothing
  used TH splices: False
  where
exports:
  MovingAverage.findAverage
  MovingAverage.moving
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Functor.Identity base-4.9.0.0:Data.List.NonEmpty
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Semigroup
                         base-4.9.0.0:Data.Type.Equality base-4.9.0.0:Data.Version
                         base-4.9.0.0:Data.Void base-4.9.0.0:GHC.Exts
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.Traversable 7ce5b7ee67475ac3d03ae825b86efd9f
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Real 08bf4acb5f2508f89d6fbcd57fe232e9
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.State d851912d62cbc95e043a9cc13c3581de
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.State.Class b303b4a4ee6363bc95266312b9afc751
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 16a585e7f12cd771300b3cab638df233
f63f2269910bc8404b90308df19460cf
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   MovingAverage.$trModule2
                   MovingAverage.$trModule1) -}
a3afb9f946ab64c402fcd7aa50d05c6a
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "MovingAverage"#) -}
550af3022c4fed3d11bdf5788626f8ce
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "hw6-0.1.0.0-3LNkNAhD9rXI9R806tlhLb"#) -}
5ae0e6a2b30511c9e6d7ba9ddb18f64a
  $wfindAverage ::
    GHC.Types.Int
    -> GHC.Types.Double
    -> [GHC.Types.Double]
    -> (# GHC.Types.Double, [GHC.Types.Double] #)
  {- Arity: 3, Strictness: <L,1*U(U)><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Double)
                   (w2 :: [GHC.Types.Double]) ->
                 let {
                   s1 :: [GHC.Types.Double]
                   = case w of wild1 { GHC.Types.I# y ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<# 0# y) of wild {
                       GHC.Types.False -> MovingAverage.findAverage2
                       GHC.Types.True
                       -> GHC.List.reverse1
                            @ GHC.Types.Double
                            (GHC.List.$wunsafeTake
                               @ GHC.Types.Double
                               y
                               (GHC.List.reverse1
                                  @ GHC.Types.Double
                                  (GHC.Base.++
                                     @ GHC.Types.Double
                                     w2
                                     (GHC.Types.:
                                        @ GHC.Types.Double
                                        w1
                                        (GHC.Types.[] @ GHC.Types.Double)))
                                  (GHC.Types.[] @ GHC.Types.Double)))
                            (GHC.Types.[] @ GHC.Types.Double) } }
                 } in
                 (# case MovingAverage.$wgo s1 0.0## of ww { DEFAULT ->
                    case GHC.List.$wlenAcc @ GHC.Types.Double s1 0# of ww2 { DEFAULT ->
                    case GHC.Prim./##
                           ww
                           (GHC.Prim.int2Double# ww2) of wild2 { DEFAULT ->
                    GHC.Types.D# wild2 } } },
                    s1 #)) -}
0f6ff2811b9c78d7ad5e9258d8392491
  $wgo :: [GHC.Types.Double] -> GHC.Prim.Double# -> GHC.Prim.Double#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
95f3c20c305976cae1908e17d233b69a
  findAverage ::
    GHC.Types.Int
    -> GHC.Types.Double
    -> Control.Monad.Trans.State.Lazy.State
         [GHC.Types.Double] GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(U)><L,U><L,1*U>m,
     Unfolding: InlineRule (0, True, True)
                MovingAverage.findAverage1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Double>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <[GHC.Types.Double]>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Double>_N)) -}
b5bcf668f2d2d0bf03b012ff60d2b68f
  findAverage1 ::
    GHC.Types.Int
    -> GHC.Types.Double
    -> [GHC.Types.Double]
    -> Data.Functor.Identity.Identity
         (GHC.Types.Double, [GHC.Types.Double])
  {- Arity: 3, Strictness: <L,1*U(U)><L,U><L,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Double)
                   (w2 :: [GHC.Types.Double]) ->
                 case MovingAverage.$wfindAverage w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(GHC.Types.Double, [GHC.Types.Double])>_R)) }) -}
b55db21ff2b67a70695fbce4f6e56535
  findAverage2 :: [GHC.Types.Double]
  {- Unfolding: (GHC.List.reverse1
                   @ GHC.Types.Double
                   (GHC.Types.[] @ GHC.Types.Double)
                   (GHC.Types.[] @ GHC.Types.Double)) -}
2851e284d9d05f60a8b48c372bb04fe9
  moving :: GHC.Types.Int -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 2, Strictness: <L,U(U)><S,1*U>,
     Unfolding: (\ (n :: GHC.Types.Int) (xs :: [GHC.Types.Double]) ->
                 letrec {
                   $wgo1 :: [GHC.Types.Double]
                            -> [GHC.Types.Double]
                            -> (# [GHC.Types.Double], [GHC.Types.Double] #)
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ (w :: [GHC.Types.Double]) (w1 :: [GHC.Types.Double]) ->
                     case w of wild {
                       [] -> (# GHC.Types.[] @ GHC.Types.Double, w1 #)
                       : y ys
                       -> let {
                            ds :: Data.Functor.Identity.Identity
                                    (GHC.Types.Double, [GHC.Types.Double])
                            = case MovingAverage.$wfindAverage n y w1 of ww { (#,#) ww1 ww2 ->
                              (ww1, ww2)
                                `cast`
                              (Sym (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Double, [GHC.Types.Double])>_R)) }
                          } in
                          let {
                            ds3 :: Data.Functor.Identity.Identity
                                     ([GHC.Types.Double], [GHC.Types.Double])
                            = case $wgo1
                                     ys
                                     (case ds
                                             `cast`
                                           (Data.Functor.Identity.N:Identity[0]
                                                <(GHC.Types.Double,
                                                  [GHC.Types.Double])>_R) of wild1 { (,) a1 s' ->
                                      s' }) of ww { (#,#) ww1 ww2 ->
                              (ww1, ww2)
                                `cast`
                              (Sym (Data.Functor.Identity.N:Identity[0]
                                        <([GHC.Types.Double], [GHC.Types.Double])>_R)) }
                          } in
                          (# GHC.Types.:
                               @ GHC.Types.Double
                               (case ds
                                       `cast`
                                     (Data.Functor.Identity.N:Identity[0]
                                          <(GHC.Types.Double,
                                            [GHC.Types.Double])>_R) of wild1 { (,) a1 s' ->
                                a1 })
                               (case ds3
                                       `cast`
                                     (Data.Functor.Identity.N:Identity[0]
                                          <([GHC.Types.Double],
                                            [GHC.Types.Double])>_R) of wild1 { (,) x s'' ->
                                x }),
                             case ds3
                                    `cast`
                                  (Data.Functor.Identity.N:Identity[0]
                                       <([GHC.Types.Double],
                                         [GHC.Types.Double])>_R) of wild1 { (,) x s'' ->
                             s'' } #) }
                 } in
                 case $wgo1
                        xs
                        (GHC.Types.[] @ GHC.Types.Double) of ww { (#,#) ww1 ww2 ->
                 ww1 }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

